# Issues and Solutions with Assigned Projects

Here are the issues encountered while trying to run the five projects assigned to us, along with possible ways they could have been rectified:

- In the Slashbot project, the code appends the directory `"C:/NCSU/Sem 1/SE/Project 3/slashbot/"` to the Python `sys.path` list (https://github.com/secheaper/slashbot/blob/main/src/bot.py#L24C1-L29C1), violating best practices by hardcoding values in the source code. So as a user, it led to import errors as this path is different from where the project was cloned in my local PC (the path may differ in different environments). This practice hinders code portability, maintenance, and reusability, as hardcoded values are less adaptable to different environments, require manual updates, and can introduce errors. To avoid hardcoding, we wish to use configuration files, environment variables, or command-line arguments for more flexible and maintainable code.

- The code formatter used in the Slashbot project, specifically the `black.yml` file, lacks comments or explanations, violating the software engineering best practice of "Code Documentation and Comments." This omission can hinder collaboration and make it challenging to understand and modify the workflow configuration. To adhere to best practices, we wish to include informative comments or documentation within the YAML file, explaining the purpose of each section and its intended behavior, making it easier for others to comprehend, contribute, and maintain the workflow configuration.

- While operating the recipe recommender, project data is hardcoded and manually stored in the databases even for dynamic data. This practice does not align with software engineering best practices. We had to inspect the code files, create databases manually, and populate the tables with data to run the project. So, we wish to use dynamic data for projects like recipe recommendar or create a script file which creates and pushes database files automatically by running a command to follow the best practices.

- When running most of the projects and executing the command to install packages from requirements.txt, numerous packages failed to install. The issue stemmed from inconsistencies in requirements.txt, where some packages had version numbers specified while others did not. This lack of version clarity not only made it challenging to determine which package versions to install but also contributed to the script's failures. To address this, we aim to enhance our documentation, emphasizing the significance of specifying package versions and elucidating any interdependencies between packages to assist users in achieving successful installations.

- In several of our projects, we encountered a situation where an excessive number of commits were concentrated within a single file. These commits often included changes related to 2 to 3 distinct use cases, all bundled together in one commit. This practice proved to be rather counterproductive as it substantially complicated our code comprehension and introduced significant challenges during debugging sessions unrelated to the changes made. It is widely recognized as a best practice in software development to adopt a more granular approach by creating smaller, more focused commits, each addressing a single use case. In light of these experiences, we are committed to learning from our past projects and ensuring that we avoid this mistake in our future endeavors.

- In our software development endeavors, we've noticed a recurring issue across several projects: the absence of test cases designed to handle failure scenarios. When executing these projects, we encountered numerous situations where they simply didn't perform as expected for certain cases. These operational hiccups necessitated extensive debugging efforts. This experience has underscored the importance of comprehensive testing, which includes not just the typical use cases but also edge scenarios, both for successful outcomes and for anticipated failures. By doing so, we gain a more profound understanding of our project's limitations, enabling us to address potential issues proactively. Moving forward, we are committed to refining our testing practices, ensuring that they encompass all possible scenarios, thereby enhancing the robustness and reliability of our projects. Expanding on this commitment, we are dedicated to providing comprehensive project documentation that not only outlines its capabilities but also explicitly details any limitations. For instance, in the case of Slashbot, we encountered a scenario where expense calculations were only applicable to specific years, leading to complications when operating the project with current dates. By documenting such scenarios, we aim to empower users with a clear understanding of the project's scope and constraints, ensuring they can effectively utilize it with full awareness of its data compatibility.

- Slashbot stores user data as Python objects in binary files with a `.pickle` extension. When the code needs to retrieve user data, it reads the pickle file with the matching user ID (chat ID), deserializes the data, and returns it as a Python object - https://github.com/secheaper/slashbot/blob/main/src/bot.py#L1259-L1277. While this approach allows for persistent data storage, it can lead to issues when existing pickle files of the developers are present in the `./data` directory (https://github.com/secheaper/slashbot/tree/main/src/data) for new users. The software takes care of generating a new .pickle file with the user's chat ID on running the application (https://github.com/secheaper/slashbot/blob/main/src/bot.py#L152-L156). Developers pushing locally generated `.pickle` files to the main repository violates the best practice of "Version Control and Collaboration." This practice increases repository size, causes potential merge conflicts, and poses security concerns. To rectify this, we wish to add `.pickle` files to the project's `.gitignore` file to exclude them from version control, ensuring a cleaner and more efficient collaboration environment while preserving user data locally.

These issues and solutions highlight the importance of adhering to best practices in software engineering to enhance code quality, maintainability, and collaboration.
